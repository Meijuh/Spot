# -*- coding: utf-8 -*-
#+TITLE: =autfilt=
#+SETUPFILE: setup.org
#+HTML_LINK_UP: tools.html

The =autfilt= tool can filter, transform, and convert a stream of automata.

The tool operates a loop over 5 phases:
- input one automaton
- optionally preprocess the automaton
- optionally filter the automaton (i.e., decide whether to ignore the
  automaton or continue with it)
- optionally postprocess the automaton
- output the automaton

The simplest way to use the tool is simply to use it for input and
output (i.e., format conversion) without any transformation and
filtering.

* Conversion between formats

=autfilt= can read automata written in the [[http://adl.github.io/hoaf/][Hanoi Omega Automata
Format]], as [[http://spinroot.com/spin/Man/never.html][Spin never claims]], or using [[http://www.tcs.hut.fi/Software/lbtt/doc/html/Format-for-automata.html][LBTT's format]].  Automata in
those formats (even a mix of those formats) can be concatenated in the
same stream, =autfilt= will process them in batch.

The output format can be controlled using [[file:oaut.org][the common output options]]
(like =--spin=, =--lbtt=, =--dot=, =--hoaf=...).

#+BEGIN_SRC sh :results silent :exports both
cat >example.hoa <<EOF
HOA: v1
States: 1
Start: 0
AP: 1 "p0"
Acceptance: 1 Inf(0)
--BODY--
State: 0
[0] 0 {0}
[!0] 0
--END--
EOF
autfilt example.hoa --dot
#+END_SRC

#+BEGIN_SRC sh :results verbatim :exports results
SPOT_DOTEXTRA= autfilt example.hoa --dot=
#+END_SRC

#+RESULTS:
: digraph G {
:   rankdir=LR
:   I [label="", style=invis, width=0]
:   I -> 0
:   0 [label="0"]
:   0 -> 0 [label="p0\n{0}"]
:   0 -> 0 [label="!p0"]
: }

The =--spin= options implicitly requires a degeneralization:

#+BEGIN_SRC sh :results verbatim :exports both
autfilt example.hoa --spin
#+END_SRC

#+RESULTS:
#+begin_example
never {
accept_init:
  if
  :: ((p0)) -> goto accept_init
  :: ((!(p0))) -> goto T0_S2
  fi;
T0_S2:
  if
  :: ((p0)) -> goto accept_init
  :: ((!(p0))) -> goto T0_S2
  fi;
}
#+end_example

#+BEGIN_SRC sh :results verbatim :exports both
autfilt example.hoa --lbtt
#+END_SRC

#+RESULTS:
: 1 1t
: 0 1
: 0 0 -1 p0
: 0 -1 ! p0
: -1

* Displaying statistics

One special output format of =autfilt= is the statistic output.  For
instance the following command calls [[file:randaut.org][=randaut=]] to generate 10 random
automata, and pipe the result into =autfilt= to display various
statistics.


#+BEGIN_SRC sh :results verbatim :exports both
randaut --hoa -n 10 -A0..2 -Q10..20 -d0.05 2 |
autfilt --stats='%s states, %e edges, %a acc-sets, %c SCCs, det=%d'
#+END_SRC

#+RESULTS:
#+begin_example
16 states, 28 edges, 1 acc-sets, 1 SCCs, det=0
19 states, 37 edges, 0 acc-sets, 1 SCCs, det=0
16 states, 24 edges, 1 acc-sets, 1 SCCs, det=0
12 states, 16 edges, 0 acc-sets, 5 SCCs, det=0
12 states, 17 edges, 2 acc-sets, 3 SCCs, det=0
15 states, 21 edges, 2 acc-sets, 5 SCCs, det=0
10 states, 12 edges, 0 acc-sets, 4 SCCs, det=1
10 states, 14 edges, 1 acc-sets, 1 SCCs, det=0
19 states, 27 edges, 1 acc-sets, 1 SCCs, det=0
11 states, 12 edges, 1 acc-sets, 9 SCCs, det=1
#+end_example

The following =%= sequences are available:
#+BEGIN_SRC sh :results verbatim :exports results
autfilt --help | sed -n '/^  %%/,/^$/p' | sed '$d'
#+END_SRC
#+RESULTS:
#+begin_example
  %%                         a single %
  %A, %a                     number of acceptance pairs or sets
  %C, %c                     number of SCCs
  %d                         1 if the output is deterministic, 0 otherwise
  %E, %e                     number of edges
  %F                         name of the input file
  %n                         number of nondeterministic states in output
  %p                         1 if the output is complete, 0 otherwise
  %r                         conversion time (including post-processings, but
                             not parsing) in seconds
  %S, %s                     number of states
  %T, %t                     number of transitions
#+end_example

When a letter is available both as uppercase and lowercase, the
uppercase version refer to the input automaton, while the lowercase
refer to the output automaton.  Of course this distinction makes sense
only if =autfilt= was instructed to perform an operation on the input
automaton.

* Filtering automata

=autfilt= supports multiple ways to filter automata based on different
characteristics of the automaton.

#+BEGIN_SRC sh :results verbatim :exports results
autfilt --help | sed -n '/Filtering options.*:/,/^$/p' | sed '1d;$d'
#+END_SRC
#+RESULTS:
#+begin_example
      --acc-sets=RANGE       keep automata whose number of acceptance sets are
                             in RANGE
      --are-isomorphic=FILENAME   keep automata that are isomorphic to the
                             automaton in FILENAME
      --edges=RANGE          keep automata whose number of edges are in RANGE
      --intersect=FILENAME   keep automata whose languages have an non-empty
                             intersection with the automaton from FILENAME
      --is-complete          keep complete automata
      --is-deterministic     keep deterministic automata
      --is-empty             keep automata with an empty language
      --states=RANGE         keep automata whose number of states are in RANGE
  -u, --unique               do not output the same automaton twice (same in
                             the sense that they are isomorphic)
  -v, --invert-match         select non-matching automata
#+end_example

For instance =--states=2..5 --acc-sets=3= will /keep/ only automata that
use 3 acceptance sets, and that have between 2 and 5 states.

Except for =--unique=, all these filters can be inverted.  Using
=--states=2..5 --acc-sets=3 -v= will /drop/ all automata that use 3
acceptance sets and that have between 2 and 5 states, and keep the
others.

* Simplifying automata

The standard set of automata simplification routines (these are often
referred to as the "post-processing" routines, because these are the
procedures performed by [[file:ltl2tgba.org][=ltl2tgba=]] after translating a formula into a
TGBA) are available through the following options.

This set of options controls the desired type of output automaton:

#+BEGIN_SRC sh :results verbatim :exports results
autfilt --help | sed -n '/Output automaton type:/,/^$/p' | sed '1d;$d'
#+END_SRC
#+RESULTS:
:   -B, --ba                   Büchi Automaton
:       --generic              Any acceptance is allowed (default)
:   -M, --monitor              Monitor (accepts all finite prefixes of the given
:                              property)
:       --tgba                 Transition-based Generalized Büchi Automaton

These options specifies desired properties:

#+BEGIN_SRC sh :results verbatim :exports results
autfilt --help | sed -n '/Translation intent:/,/^$/p' | sed '1d;$d'
#+END_SRC
#+RESULTS:
:   -a, --any                  no preference, do not bother making it small or
:                              deterministic (default)
:   -C, --complete             output a complete automaton (combine with other
:                              intents)
:   -D, --deterministic        prefer deterministic automata
:       --small                prefer small automata
:   -S, --state-based-acceptance, --sbacc
:                              define the acceptance using states

Finally, the following switches control the amount of effort applied
to reach the desired properties:

#+BEGIN_SRC sh :results verbatim :exports results
autfilt --help | sed -n '/Optimization level:/,/^$/p' | sed '1d;$d'
#+END_SRC
#+RESULTS:
:       --high                 all available optimizations (slow)
:       --low                  minimal optimizations (fast, default)
:       --medium               moderate optimizations


By default, =--any --low= is used, which cause all simplifications to
be skipped.  If you want to reduce the size of the automaton, try
=--small --high= and if you want to try to make it deterministic
(their is to guaranty of result, this is only a preference), try
=--deterministic --high=.

* Transformations

The following transformations are available:

#+BEGIN_SRC sh :results verbatim :exports results
autfilt --help | sed -n '/Transformations:/,/^$/p' | sed '1d;$d'
#+END_SRC

#+RESULTS:
#+begin_example
      --cleanup-acceptance   remove unused acceptance sets from the automaton
      --cnf-acceptance       put the acceptance condition in Conjunctive Normal
                             Form
      --complement-acceptance   complement the acceptance condition (without
                             touching the automaton)
      --destut               allow less stuttering
      --dnf-acceptance       put the acceptance condition in Disjunctive Normal
                             Form
      --exclusive-ap=AP,AP,...   if any of those APs occur in the automaton,
                             restrict all edges to ensure two of them may not
                             be true at the same time.  Use this option
                             multiple times to declare independent groups of
                             exclusive propositions.
      --instut[=1|2]         allow more stuttering (two possible algorithms)
      --keep-states=NUM[,NUM...]   only keep specified states.  The first state
                             will be the new initial state.  Implies
                             --remove-unreachable-states.
      --mask-acc=NUM[,NUM...]   remove all transitions in specified acceptance
                             sets
      --merge-transitions    merge transitions with same destination and
                             acceptance
      --product=FILENAME     build the product with the automaton in FILENAME
      --randomize[=s|t]      randomize states and transitions (specify 's' or
                             't' to randomize only states or transitions)
      --remove-ap=AP[=0|=1][,AP...]
                             remove atomic propositions either by existential
                             quantification, or by assigning them 0 or 1
      --remove-dead-states   remove states that are unreachable, or that cannot
                             belong to an infinite path
      --remove-fin           rewrite the automaton without using Fin acceptance

      --remove-unreachable-states
                             remove states that are unreachable from the
                             initial state
      --separate-sets        if both Inf(x) and Fin(x) appear in the acceptance
                             condition, replace Fin(x) by a new Fin(y) and
                             adjust the automaton
      --simplify-exclusive-ap   if --exclusive-ap is used, assume those AP
                             groups are actually exclusive in the system to
                             simplify the expression of transition labels
                             (implies --merge-transitions)
      --strip-acceptance     remove the acceptance condition and all acceptance
                             sets
#+end_example

* Examples

Here is an automaton with transition-based acceptance:

#+BEGIN_SRC sh :results silent :exports both
cat >aut-ex1.hoa<<EOF
HOA: v1
States: 3
Start: 0
AP: 2 "a" "b"
acc-name: Buchi
Acceptance: 4 Inf(0)&Fin(1)&Fin(3) | Inf(2)&Inf(3) | Inf(1)
--BODY--
State: 0 {3}
[t] 0
[0] 1 {1}
[!0] 2 {0}
State: 1 {3}
[1] 0
[0&1] 1 {0}
[!0&1] 2 {2}
State: 2
[!1] 0
[0&!1] 1 {0}
[!0&!1] 2 {0}
--END--
EOF
#+END_SRC

(Note: the '=.=' argument passed to =--dot= below hides default
options discussed [[file:oaut.org::#default-dot][on another page]], while the '=a=' causes the
acceptance condition to be displayed.)

#+NAME: autfilt-ex1
#+BEGIN_SRC sh :results verbatim :exports code
autfilt aut-ex1.hoa --dot=.a
#+END_SRC

#+RESULTS: autfilt-ex1
#+begin_example
digraph G {
  rankdir=LR
  label=<(Fin(<font color="#F17CB0">❶</font>) &amp; Fin(<font color="#B276B2">❸</font>) &amp; Inf(<font color="#5DA5DA">⓿</font>)) | (Inf(<font color="#FAA43A">❷</font>)&amp;Inf(<font color="#B276B2">❸</font>)) | Inf(<font color="#F17CB0">❶</font>)>
  labelloc="t"
  fontname="Lato"
  node [fontname="Lato"]
  edge [fontname="Lato"]
  node[style=filled, fillcolor="#ffffa0"] edge[arrowhead=vee, arrowsize=.7]
  I [label="", style=invis, width=0]
  I -> 0
  0 [label="0"]
  0 -> 0 [label=<1<br/><font color="#B276B2">❸</font>>]
  0 -> 1 [label=<a<br/><font color="#F17CB0">❶</font><font color="#B276B2">❸</font>>]
  0 -> 2 [label=<!a<br/><font color="#5DA5DA">⓿</font><font color="#B276B2">❸</font>>]
  1 [label="1"]
  1 -> 0 [label=<b<br/><font color="#B276B2">❸</font>>]
  1 -> 1 [label=<a &amp; b<br/><font color="#5DA5DA">⓿</font><font color="#B276B2">❸</font>>]
  1 -> 2 [label=<!a &amp; b<br/><font color="#FAA43A">❷</font><font color="#B276B2">❸</font>>]
  2 [label="2"]
  2 -> 0 [label=<!b>]
  2 -> 1 [label=<a &amp; !b<br/><font color="#5DA5DA">⓿</font>>]
  2 -> 2 [label=<!a &amp; !b<br/><font color="#5DA5DA">⓿</font>>]
}
#+end_example

#+BEGIN_SRC dot :file autfilt-ex1.png :cmdline -Tpng :var txt=autfilt-ex1 :exports results
$txt
#+END_SRC

#+RESULTS:
[[file:autfilt-ex1.png]]

Using =-S= will "push" the acceptance membership of the transitions to the states:

#+NAME: autfilt-ex2
#+BEGIN_SRC sh :results verbatim :exports code
autfilt -S aut-ex1.hoa --dot=.a
#+END_SRC

#+RESULTS: autfilt-ex2
#+begin_example
digraph G {
  rankdir=LR
  label=<(Fin(<font color="#F17CB0">❶</font>) &amp; Fin(<font color="#B276B2">❸</font>) &amp; Inf(<font color="#5DA5DA">⓿</font>)) | (Inf(<font color="#FAA43A">❷</font>)&amp;Inf(<font color="#B276B2">❸</font>)) | Inf(<font color="#F17CB0">❶</font>)>
  labelloc="t"
  node [shape="circle"]
  fontname="Lato"
  node [fontname="Lato"]
  edge [fontname="Lato"]
  node[style=filled, fillcolor="#ffffa0"] edge[arrowhead=vee, arrowsize=.7]
  I [label="", style=invis, width=0]
  I -> 0
  0 [label=<0<br/><font color="#B276B2">❸</font>>]
  0 -> 0 [label=<1>]
  0 -> 1 [label=<a>]
  0 -> 2 [label=<!a>]
  1 [label=<1<br/><font color="#F17CB0">❶</font><font color="#B276B2">❸</font>>]
  1 -> 0 [label=<b>]
  1 -> 6 [label=<a &amp; b>]
  1 -> 7 [label=<!a &amp; b>]
  2 [label=<2<br/><font color="#5DA5DA">⓿</font><font color="#B276B2">❸</font>>]
  2 -> 3 [label=<!b>]
  2 -> 4 [label=<a &amp; !b>]
  2 -> 5 [label=<!a &amp; !b>]
  3 [label=<3>]
  3 -> 0 [label=<1>]
  3 -> 1 [label=<a>]
  3 -> 2 [label=<!a>]
  4 [label=<4<br/><font color="#5DA5DA">⓿</font>>]
  4 -> 0 [label=<b>]
  4 -> 6 [label=<a &amp; b>]
  4 -> 7 [label=<!a &amp; b>]
  5 [label=<5<br/><font color="#5DA5DA">⓿</font>>]
  5 -> 3 [label=<!b>]
  5 -> 4 [label=<a &amp; !b>]
  5 -> 5 [label=<!a &amp; !b>]
  6 [label=<6<br/><font color="#5DA5DA">⓿</font><font color="#B276B2">❸</font>>]
  6 -> 0 [label=<b>]
  6 -> 6 [label=<a &amp; b>]
  6 -> 7 [label=<!a &amp; b>]
  7 [label=<7<br/><font color="#FAA43A">❷</font><font color="#B276B2">❸</font>>]
  7 -> 3 [label=<!b>]
  7 -> 4 [label=<a &amp; !b>]
  7 -> 5 [label=<!a &amp; !b>]
}
#+end_example

#+BEGIN_SRC dot :file autfilt-ex2.png :cmdline -Tpng :var txt=autfilt-ex2 :exports results
$txt
#+END_SRC

#+RESULTS:
[[file:autfilt-ex2.png]]

Using =--cnf-acceptance= simply rewrites the acceptance condition in Conjunctive Normal Form:

#+NAME: autfilt-ex3
#+BEGIN_SRC sh :results verbatim :exports code
autfilt --cnf-acceptance aut-ex1.hoa --dot=.a
#+END_SRC

#+RESULTS: autfilt-ex3
#+begin_example
digraph G {
  rankdir=LR
  label=<(Inf(<font color="#5DA5DA">⓿</font>) | Inf(<font color="#F17CB0">❶</font>) | Inf(<font color="#B276B2">❸</font>)) &amp; (Fin(<font color="#B276B2">❸</font>) | Inf(<font color="#F17CB0">❶</font>) | Inf(<font color="#FAA43A">❷</font>))>
  labelloc="t"
  fontname="Lato"
  node [fontname="Lato"]
  edge [fontname="Lato"]
  node[style=filled, fillcolor="#ffffa0"] edge[arrowhead=vee, arrowsize=.7]
  I [label="", style=invis, width=0]
  I -> 0
  0 [label="0"]
  0 -> 0 [label=<1<br/><font color="#B276B2">❸</font>>]
  0 -> 1 [label=<a<br/><font color="#F17CB0">❶</font><font color="#B276B2">❸</font>>]
  0 -> 2 [label=<!a<br/><font color="#5DA5DA">⓿</font><font color="#B276B2">❸</font>>]
  1 [label="1"]
  1 -> 0 [label=<b<br/><font color="#B276B2">❸</font>>]
  1 -> 1 [label=<a &amp; b<br/><font color="#5DA5DA">⓿</font><font color="#B276B2">❸</font>>]
  1 -> 2 [label=<!a &amp; b<br/><font color="#FAA43A">❷</font><font color="#B276B2">❸</font>>]
  2 [label="2"]
  2 -> 0 [label=<!b>]
  2 -> 1 [label=<a &amp; !b<br/><font color="#5DA5DA">⓿</font>>]
  2 -> 2 [label=<!a &amp; !b<br/><font color="#5DA5DA">⓿</font>>]
}
#+end_example

#+BEGIN_SRC dot :file autfilt-ex3.png :cmdline -Tpng :var txt=autfilt-ex3 :exports results
$txt
#+END_SRC

#+RESULTS:
[[file:autfilt-ex3.png]]


Using =--remove-fin= transforms the automaton to remove all traces
of Fin-acceptance: this usually requires adding non-deterministic jumps to
altered copies of strongly-connected components.

#+NAME: autfilt-ex4
#+BEGIN_SRC sh :results verbatim :exports code
autfilt --remove-fin aut-ex1.hoa --dot=.a
#+END_SRC

#+RESULTS: autfilt-ex4
#+begin_example
digraph G {
  rankdir=LR
  label=<Inf(<font color="#5DA5DA">⓿</font>) | Inf(<font color="#F17CB0">❶</font>) | (Inf(<font color="#FAA43A">❷</font>)&amp;Inf(<font color="#B276B2">❸</font>))>
  labelloc="t"
  fontname="Lato"
  node [fontname="Lato"]
  edge [fontname="Lato"]
  node[style=filled, fillcolor="#ffffa0"] edge[arrowhead=vee, arrowsize=.7]
  I [label="", style=invis, width=0]
  I -> 0
  0 [label="0"]
  0 -> 0 [label=<1<br/><font color="#B276B2">❸</font>>]
  0 -> 1 [label=<a<br/><font color="#F17CB0">❶</font><font color="#B276B2">❸</font>>]
  0 -> 2 [label=<!a<br/><font color="#B276B2">❸</font>>]
  1 [label="1"]
  1 -> 0 [label=<b<br/><font color="#B276B2">❸</font>>]
  1 -> 1 [label=<a &amp; b<br/><font color="#B276B2">❸</font>>]
  1 -> 2 [label=<!a &amp; b<br/><font color="#FAA43A">❷</font><font color="#B276B2">❸</font>>]
  2 [label="2"]
  2 -> 0 [label=<!b>]
  2 -> 1 [label=<a &amp; !b>]
  2 -> 2 [label=<!a &amp; !b>]
  2 -> 3 [label=<!a &amp; !b>]
  3 [label="3"]
  3 -> 3 [label=<!a &amp; !b<br/><font color="#5DA5DA">⓿</font>>]
}
#+end_example

#+BEGIN_SRC dot :file autfilt-ex4.png :cmdline -Tpng :var txt=autfilt-ex4 :exports results
$txt
#+END_SRC

#+RESULTS:
[[file:autfilt-ex4.png]]

Use =--mask-acc=NUM= to remove some acceptances sets and all
transitions they contain.  The acceptance condition will be updated to
reflect the fact that these sets can never be visited.

#+NAME: autfilt-ex5
#+BEGIN_SRC sh :results verbatim :exports code
autfilt --mask-acc=1,2 aut-ex1.hoa --dot=.a
#+END_SRC

#+RESULTS: autfilt-ex5
#+begin_example
digraph G {
  rankdir=LR
  label=<Fin(<font color="#F17CB0">❶</font>) &amp; Inf(<font color="#5DA5DA">⓿</font>)>
  labelloc="t"
  fontname="Lato"
  node [fontname="Lato"]
  edge [fontname="Lato"]
  node[style=filled, fillcolor="#ffffa0"] edge[arrowhead=vee, arrowsize=.7]
  I [label="", style=invis, width=0]
  I -> 0
  0 [label="0"]
  0 -> 0 [label=<1<br/><font color="#F17CB0">❶</font>>]
  0 -> 1 [label=<!a<br/><font color="#5DA5DA">⓿</font><font color="#F17CB0">❶</font>>]
  1 [label="1"]
  1 -> 0 [label=<!b>]
  1 -> 2 [label=<a &amp; !b<br/><font color="#5DA5DA">⓿</font>>]
  1 -> 1 [label=<!a &amp; !b<br/><font color="#5DA5DA">⓿</font>>]
  2 [label="2"]
  2 -> 0 [label=<b<br/><font color="#F17CB0">❶</font>>]
  2 -> 2 [label=<a &amp; b<br/><font color="#5DA5DA">⓿</font><font color="#F17CB0">❶</font>>]
}
#+end_example

#+BEGIN_SRC dot :file autfilt-ex5.png :cmdline -Tpng :var txt=autfilt-ex5 :exports results
$txt
#+END_SRC

#+RESULTS:
[[file:autfilt-ex5.png]]


Atomic propositions can be removed from an automaton in three ways:
- use ~--remove-ap=a~ to remove =a= by existential quantification, i.e., both =a= and its negation will be replaced by true.
  This does not remove any transition.
- use ~--remove-ap=a=0~ to keep only transitions compatible with =!a= (i.e, transitions requiring =a= will be removed).
- use ~--remove-ap=a=1~ to keep only transitions compatible with =a= (i.e, transitions requiring =!a= will be removed).

Here are the results of these three options on our example:

#+NAME: autfilt-ex6a
#+BEGIN_SRC sh :results verbatim :exports code
autfilt --remove-ap=a aut-ex1.hoa --dot=.a
#+END_SRC

#+RESULTS: autfilt-ex6a
#+begin_example
digraph G {
  rankdir=LR
  label=<(Fin(<font color="#F17CB0">❶</font>) &amp; Fin(<font color="#B276B2">❸</font>) &amp; Inf(<font color="#5DA5DA">⓿</font>)) | (Inf(<font color="#FAA43A">❷</font>)&amp;Inf(<font color="#B276B2">❸</font>)) | Inf(<font color="#F17CB0">❶</font>)>
  labelloc="t"
  fontname="Lato"
  node [fontname="Lato"]
  edge [fontname="Lato"]
  node[style=filled, fillcolor="#ffffa0"] edge[arrowhead=vee, arrowsize=.7]
  I [label="", style=invis, width=0]
  I -> 0
  0 [label="0"]
  0 -> 0 [label=<1<br/><font color="#B276B2">❸</font>>]
  0 -> 1 [label=<1<br/><font color="#F17CB0">❶</font><font color="#B276B2">❸</font>>]
  0 -> 2 [label=<1<br/><font color="#5DA5DA">⓿</font><font color="#B276B2">❸</font>>]
  1 [label="1"]
  1 -> 0 [label=<b<br/><font color="#B276B2">❸</font>>]
  1 -> 1 [label=<b<br/><font color="#5DA5DA">⓿</font><font color="#B276B2">❸</font>>]
  1 -> 2 [label=<b<br/><font color="#FAA43A">❷</font><font color="#B276B2">❸</font>>]
  2 [label="2"]
  2 -> 0 [label=<!b>]
  2 -> 1 [label=<!b<br/><font color="#5DA5DA">⓿</font>>]
  2 -> 2 [label=<!b<br/><font color="#5DA5DA">⓿</font>>]
}
#+end_example

#+BEGIN_SRC dot :file autfilt-ex6a.png :cmdline -Tpng :var txt=autfilt-ex6a :exports results
$txt
#+END_SRC

#+RESULTS:
[[file:autfilt-ex6a.png]]

#+NAME: autfilt-ex6b
#+BEGIN_SRC sh :results verbatim :exports code
autfilt --remove-ap=a=0 aut-ex1.hoa --dot=.a
#+END_SRC

#+RESULTS: autfilt-ex6b
#+begin_example
digraph G {
  rankdir=LR
  label=<(Fin(<font color="#F17CB0">❶</font>) &amp; Fin(<font color="#B276B2">❸</font>) &amp; Inf(<font color="#5DA5DA">⓿</font>)) | (Inf(<font color="#FAA43A">❷</font>)&amp;Inf(<font color="#B276B2">❸</font>)) | Inf(<font color="#F17CB0">❶</font>)>
  labelloc="t"
  fontname="Lato"
  node [fontname="Lato"]
  edge [fontname="Lato"]
  node[style=filled, fillcolor="#ffffa0"] edge[arrowhead=vee, arrowsize=.7]
  I [label="", style=invis, width=0]
  I -> 0
  0 [label="0"]
  0 -> 0 [label=<1<br/><font color="#B276B2">❸</font>>]
  0 -> 1 [label=<1<br/><font color="#5DA5DA">⓿</font><font color="#B276B2">❸</font>>]
  1 [label="1"]
  1 -> 0 [label=<!b>]
  1 -> 1 [label=<!b<br/><font color="#5DA5DA">⓿</font>>]
}
#+end_example

#+BEGIN_SRC dot :file autfilt-ex6b.png :cmdline -Tpng :var txt=autfilt-ex6b :exports results
$txt
#+END_SRC

#+RESULTS:
[[file:autfilt-ex6b.png]]

#+NAME: autfilt-ex6c
#+BEGIN_SRC sh :results verbatim :exports code
autfilt --remove-ap=a=1 aut-ex1.hoa --dot=.a
#+END_SRC

#+RESULTS: autfilt-ex6c
#+begin_example
digraph G {
  rankdir=LR
  label=<(Fin(<font color="#F17CB0">❶</font>) &amp; Fin(<font color="#B276B2">❸</font>) &amp; Inf(<font color="#5DA5DA">⓿</font>)) | (Inf(<font color="#FAA43A">❷</font>)&amp;Inf(<font color="#B276B2">❸</font>)) | Inf(<font color="#F17CB0">❶</font>)>
  labelloc="t"
  fontname="Lato"
  node [fontname="Lato"]
  edge [fontname="Lato"]
  node[style=filled, fillcolor="#ffffa0"] edge[arrowhead=vee, arrowsize=.7]
  I [label="", style=invis, width=0]
  I -> 0
  0 [label="0"]
  0 -> 0 [label=<1<br/><font color="#B276B2">❸</font>>]
  0 -> 1 [label=<1<br/><font color="#F17CB0">❶</font><font color="#B276B2">❸</font>>]
  1 [label="1"]
  1 -> 0 [label=<b<br/><font color="#B276B2">❸</font>>]
  1 -> 1 [label=<b<br/><font color="#5DA5DA">⓿</font><font color="#B276B2">❸</font>>]
}
#+end_example

#+BEGIN_SRC dot :file autfilt-ex6c.png :cmdline -Tpng :var txt=autfilt-ex6c :exports results
$txt
#+END_SRC

#+RESULTS:
[[file:autfilt-ex6c.png]]

#+BEGIN_SRC sh :results silent :exports results
rm -f example.hoa aut-ex1.hoa
#+END_SRC
