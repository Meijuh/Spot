#!/bin/sh
# -*- coding: utf-8 -*-
# Copyright (C) 2009, 2010, 2011, 2012, 2013, 2014, 2015 Laboratoire
# de Recherche et Développement de l'Epita (LRDE).
# Copyright (C) 2003, 2004 Laboratoire d'Informatique de Paris 6 (LIP6),
# département Systèmes Répartis Coopératifs (SRC), Université Pierre
# et Marie Curie.
#
# This file is part of Spot, a model checking library.
#
# Spot is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# Spot is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


. ./defs

set -e

cat >check.txt <<\EOF
a
a U b
X a
a & b & c
a | b | (c U (d & (g U (h ^ i))))
Xa & (b U !a) & (b U !a)
Fa & Xb & GFc & Gd
Fa & Xa & GFc & Gc
Fc & X(a | Xb) & GF(a | Xb) & Gc
a R (b R c)
(a U b) U (c U d)

((Xp2)U(X(1)))&(p1 R(p2 R p0))

{a*;c}<>->GFb
{((a*;b;c)*)&((b*;a;c)*)}<>->x
{(g;y;r)*}<>->x
G({(g;y;r)*}<>->x)
G({(a;b)*}<>->x)&G({(c;d)*}<>->y)
# try sub-braces
G({{a;b}*}[]->x)&G({{c;d}*}[]->y)
{([*0] + a):c*:([*0] + b)}<>->d
{a;e;f:(g*);h}<>->d
{(a:b)* & (c*:d)}<>->e
{(a:b)*}
G{(a:b)*}
{a;b}
{(a;b)*}
G{(a;b)*}
{a*}[]->{b*}
{a*}[]=>{b*}
{a*&b}
{a*&b*}
{((!c;b*) & d);e}
{(a* & (c;b*) & d);e}
{[*2];a[*2..4]}|->b
{a[*2..5] && b[*..3]}|->c
{{[+];a;[+]} && {[+];b;[+]}}<>->c
{(a[->3]) & {[+];b}}<>->c
# This formula (built by a random formula generator), exhibited an
# infinite recursion in the translation:
{(a|[*0])[*];1}
# Example from "Beyond Hardware Verification" by Glazberg, Moulin, Orni,
# Ruah, Zarpas (2007).
{[*];req;ack}|=>{start;busy[*];done}
# Examples from "Property-by-Example Guide: a Handbook of PSL Examples"
# by Ben David and Orni (2005)/
# - 2.27.A
{end[=3]}(false)
# - 3.5.A
{[*]; {read[=3]} && {write[=2]}} |=> {(!read && !write)[*]; ready}
# - 2.33  (abridged to fit in 80 cols)
{[*];st&&comp_d_en;!comp_d_en&&good_c;{st_v[->]}&&{stop[=0];true}}|->{!d_out}

# Some tricky cases that require the rational automaton to be pruned
# before it is used in the translation.
{{b[*];c} | {{a && !a}}[=2]}
{((a&!b);((!a&!b)*))&&(!b*;(!a&b))}
# When translating this formula, we expect the translator to ignore
# `a;(f&!f)[=2];c' on one side because it as already seen it on the
# other side.
{c;a;(f&!f)[=2];c}|{b;a;(!f&f)[=2];c}

# these were mis-translated in Spot 0.9
G!{(b;1)*;a}
(G!{(b;1)*;a} && ({1;1[*3]*}[]->{(b&!a)[*2];!b&!a}))
EOF

run 0 ../checkpsl check.txt

# Make sure False has one acceptance set when generating Büchi automata
test 1 -eq `../../bin/ltl2tgba -B false --stats %a`

# In particular, Spot 0.9 would incorrectly reject the sequence:
# (a̅b;a̅b;a̅b̅);(a̅b;a̅b;a̅b̅);(a̅b;a̅b;a̅b̅);... in 'G!{(b;1)*;a}'
# This means the following automaton was incorrectly empty in Spot 0.9.
run 0 ../ltl2tgba -e -R3 '(G!{(b;1)*;a} && ({1;1[*3]*}[]->{(b&!a)[*2];!b&!a}))'

# Make sure 'a U (b U c)' has 3 states and 6 transitions,
# before and after degeneralization.
for opt in '' -DT -DS; do
  ../ltl2tgba -ks -f -R3 $opt 'a U (b U c)' > stdout
  grep 'transitions: 6$' stdout
  grep 'states: 3$' stdout
done

# Make sure '!(Ga U b)' has 3 states and 6 transitions,
# before and after degeneralization.
for opt in '' -DT -DS; do
  ../ltl2tgba -kt -f -R3 $opt '!(Ga U b)' > stdout
  grep 'sub trans.: 11$' stdout
  grep 'transitions: 6$' stdout
  grep 'states: 3$' stdout
done

# Make sure 'Ga U b' has 4 states and 6 transitions,
# before and after degeneralization.
for opt in '' -DT -DS; do
  ../ltl2tgba -kt -f -R3 $opt 'Ga U b' > stdout
  grep 'sub trans.: 12$' stdout
  grep 'transitions: 6$' stdout
  grep 'states: 4$' stdout
done

# Make sure '(G (p -> F q)) && ((X (p) U q) || ! X (p U (p && q)))'
# has 6 states and 15 transitions, before and after degeneralization.
f='(G (p -> F q)) && ((X (p) U q) || ! X (p U (p && q)))'
for opt in '' -DT -DS; do
  ../ltl2tgba -ks -f -R3 $opt "$f" > stdout
  grep 'transitions: 15$' stdout
  grep 'states: 6$' stdout
  ../ltl2tgba -ks -f -R3f $opt "$f" > stdout
  grep 'transitions: 15$' stdout
  grep 'states: 6$' stdout
done

# Make sure 'GFa & GFb & GFc & GFd & GFe & GFf'
# has 7 states and 34 transitions after degeneralization.
f='GFa & GFb & GFc & GFd & GFe & GFg'
../ltl2tgba -ks -DS -x -f "$f" > stdout
grep 'transitions: 34$' stdout
grep 'states: 7$' stdout

# Make sure 'Ga & XXXX!a' is minimized to one state.
f='Ga & XXXX!a'
../ltl2tgba -ks -f "$f" > stdout
grep 'transitions: 4$' stdout
grep 'states: 5$' stdout
../ltl2tgba -ks -Rm -f "$f" > stdout
grep 'transitions: 0$' stdout
grep 'states: 1$' stdout

# Make sure a monitor for F(a & F(b)) accepts everything.
run 0 ../ltl2tgba -M -f "F(a & F(b))" | grep ' ->' > stdout
cat >expected <<EOF
  I -> 0
  0 -> 0 [label="1"]
EOF
cmp stdout expected

# This formula caused a segfault with Spot 0.7.
run 0 ../ltl2tgba -Rm -ks -f "Gq|Gr|(G(q|FGp)&G(r|FG!p))" >stdout
grep 'transitions: 5$' stdout
grep 'states: 3$' stdout

# Adding -R3 used to make it work...
run 0 ../ltl2tgba -R3 -Rm -ks -f "Gq|Gr|(G(q|FGp)&G(r|FG!p))" >stdout
grep 'transitions: 5$' stdout
grep 'states: 3$' stdout

# Make sure FGa|GFb has the same number of states/transitions when
# output as a never claim or are a degeneralized BA in HOAF.
# The option -R1q -R1t used to cause two degeneralizations to
# occur.
run 0 ../ltl2tgba -R1q -R1t -N 'FGa|FGb' > out.never
run 0 ../ltl2tgba -XN -kt out.never > count.never
run 0 ../ltl2tgba -R1q -R1t -DS -H 'FGa|FGb' > out.hoa
run 0 ../ltl2tgba -XH -kt out.hoa > count.hoa
cmp count.never count.hoa

# The following automaton should have only 4 states.
run 0 ../ltl2tgba -R3 -ks -f '(p&XF!p)|(!p&XFp)|X(Fp&F!p)' >stdout
grep 'transitions: 7$' stdout
grep 'states: 4$' stdout

# A bug in the translation of !{xxx} when xxx reduces to false caused
# the following formula to be considered equivalent to anything...
../../bin/ltlfilt -f '!{[*2] && [*0..1]}' --equivalent-to 'false' && exit 1
../../bin/ltlfilt -f '!{[*2] && [*0..1]}' --equivalent-to 'true'

# Test some equivalences fixed in Spot 1.1.4
../../bin/ltlfilt    -f '{{a;b}[*]}'  --equivalent-to 'a & Xb'
../../bin/ltlfilt -r -f '{{a;b}[*]}'  --equivalent-to 'a & Xb'
../../bin/ltlfilt    -f '!{{a;b}[*]}' --equivalent-to '!a | X!b'
../../bin/ltlfilt -r -f '!{{a;b}[*]}' --equivalent-to '!a | X!b'
../../bin/ltlfilt    -f '{a[*];b[*]}' --equivalent-to 'a | b'
../../bin/ltlfilt -r -f '{a[*];b[*]}' --equivalent-to 'a | b'


# A couple of tests for the [:*i..j] operator
../../bin/ltlfilt -q    -f '{{a;b}[:*1..2];c}' \
		  --equivalent-to '(a&X(b&Xc)) | a&(X(b&a&X(b&Xc)))'
../../bin/ltlfilt -q -r -f '{{a;b}[:*1..2];c}' \
		  --equivalent-to '(a&X(b&Xc)) | a&(X(b&a&X(b&Xc)))'
../../bin/ltlfilt -q    -f '{{a*}[:+];c}' --equivalent-to 'Xc R a'
../../bin/ltlfilt -q -r -f '{{a*}[:+];c}' --equivalent-to 'Xc R a'
../../bin/ltlfilt -q    -f '{c && {b | [*0]}[:+]}' --equivalent-to 'c & b'
../../bin/ltlfilt -q -r -f '{c && {b | [*0]}[:+]}' --equivalent-to 'c & b'

# test unknown dot options
../../bin/ltl2tgba --dot=@ a 2>stderr && exit 1
grep 'ltl2tgba: unknown option.*@' stderr
